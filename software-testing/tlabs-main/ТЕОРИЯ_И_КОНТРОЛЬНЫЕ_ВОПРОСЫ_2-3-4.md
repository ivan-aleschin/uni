# Теория и контрольные вопросы (ЛР №2, №3, №4)

Автор: [Ваше ФИО]
Группа: [Номер группы]
Дата: 10.11.2025
Проект: «Калькулятор» (Java, Swing, JUnit 5, Mockito, JaCoCo)

---

Лабораторная №2. Unit-тестирование логики и прослойки (MVP)

Контрольные вопросы

1) В чем отличие приемочного тестирования от системного?
- Системное тестирование подтверждает, что вся система соответствует спецификации (functional + non-functional) и корректно работает как целое. Исполнители — команда тестирования, среда близка к продуктовой, охватываются интеграции и нефункциональные характеристики.
- Приемочное тестирование подтверждает, что продукт отвечает бизнес-требованиям и критериям приемки заказчика. Исполнители — заказчик/бизнес-представители/пользователи, фокус — ценность и готовность к вводу в эксплуатацию. Часто базируется на сценариях уровня пользователя.

2) Что такое моки и стабы?
- Stub (заглушка) — простой тестовый двойник, возвращающий заранее подготовленные ответы, чтобы изолировать тест от реальных зависимостей.
- Mock — двойник, который, помимо выдачи ответов, фиксирует и позволяет проверять взаимодействия (какие методы вызывались, с какими аргументами, сколько раз).
- Смежные термины: Fake (упрощенная реализация), Spy (частичный мок, проверка вызовов реальной реализации), Dummy (пустая заглушка для заполнения параметров).
- В Mockito: when(...).thenReturn(...) — стабы; verify(mock).method(...) — проверка взаимодействий (моки).

3) Как осуществляется планирование тестов?
- Определение целей и области тестирования (что проверяем, что вне области).
- Анализ рисков и приоритизация (критичные сценарии первыми).
- Стратегия и виды тестирования (unit/integration/E2E, нефункциональные аспекты).
- Среда и инфраструктура (IDE, CI, JDK, зависимости, данные).
- Критерии входа/выхода, метрики (покрытие, дефекты, скорость выполнения).
- Оценка трудозатрат, расписание, роли и ответственность.
- В проекте «Калькулятор»: план уровней — Unit (Calculator/Presenter), UI-поведение (GUI), интеграция и E2E; критерии — прохождение тестов и целевое покрытие.

4) Какие правила организации тестов вы знаете?
- One behavior per test: один сценарий — один тест, понятное имя (method_underTest_condition_expectedResult).
- AAA/Given-When-Then: четкая структура теста.
- Независимость и детерминизм: без зависимости от порядка, сети, времени (или с фиксацией времени), случайности.
- Явные граничные значения и классы эквивалентности.
- Повторное использование setup через @BeforeEach/@BeforeAll; избегать общего изменяемого состояния.
- Параметризованные тесты для однотипных проверок.
- Отдельные пакеты/модули: тесты лежат симметрично исходникам (src/test/java зеркалит src/main/java).

5) Что за шаблон Arrange-Act-Assert?
- Arrange (Подготовка): создание объектов, данных, конфигурации.
- Act (Действие): вызов тестируемого метода.
- Assert (Проверка): сравнение фактического результата с ожидаемым, а также проверка взаимодействий.
Пример (JUnit 5 + Mockito):
// ...existing code...
// Arrange
CalculatorView view = mock(CalculatorView.class);
CalculatorPresenter presenter = new CalculatorPresenterImpl(view);
when(view.getFirstArgumentAsString()).thenReturn("2");
when(view.getSecondArgumentAsString()).thenReturn("3");
// Act
presenter.onPlusClicked();
// Assert
verify(view).printResult(5.0);
verify(view, never()).displayError(anyString());
// ...existing code...

6) Какие преимущества применения unit-тестирования?
- Быстрая обратная связь, предотвращение регрессий, безопасный рефакторинг.
- Улучшение дизайна (слабая связность, четкие интерфейсы).
- Живая документация примерами использования.
- Снижение стоимости дефектов (раннее обнаружение).
- Упрощение интеграции: каждая часть надежна по отдельности.

7) Что такое тестовое покрытие?
- Метрики: линейное/инструкций, ветвлений, покрытие методов/классов. JaCoCo собирает байткод-метрики.
- Интерпретация: высокое покрытие не гарантирует отсутствие дефектов, но низкое покрытие — явный риск. Целевые пороги определяются критичностью.
- Полезные пороги: инструкции ≥80–90%, ветвления ≥70–80%. Для точек входа (Main) покрытие может быть нулевым по практическим причинам.

Полезная теория (ЛР №2)
- TDD (Red-Green-Refactor): сперва тесты, затем минимальная реализация, затем рефакторинг.
- Техники дизайна тестов: классы эквивалентности, граничные значения, таблицы решений, попарное тестирование.
- Числа с плавающей точкой: сравнения с дельтой (assertEquals(expected, actual, 1e-8)).
- Изоляция: подменяйте внешние ресурсы (I/O, сеть) моками/стабами.

---

Лабораторная №3. Тестирование графического интерфейса

Темы
- Особенности тестирования GUI: событийная модель, асинхронность, зависимость от среды (EDT в Swing), флаки-тесты.
- Подход MVP/MVVM: максимальная логика вне View, чтобы большая часть поведения покрывалась unit-тестами Presenter/ViewModel.
- Стратегии: 
  - Тесты View на уровне событий (doClick, ввод текста),
  - Вызовы методов Presenter из обработчиков,
  - Проверка визуального состояния через публичные геттеры/адаптеры.
- Среда исполнения: запуск действий на EDT (SwingUtilities.invokeAndWait), возможность headless-режима (-Djava.awt.headless=true) для CI.

Требования к пользовательскому интерфейсу (общие рекомендации)
- Ясность и предсказуемость: валидные подсказки, недопущение «молчаливых» ошибок.
- Обратная связь: явные сообщения об ошибках (деление на ноль, неверный ввод), очистка/блокировка конфликтующих полей.
- Доступность: навигация с клавиатуры, контрастность, размеры кликабельных областей.
- Согласованность: единый стиль и поведение, понятные надписи и локализация при необходимости.
- Защита от ошибок: валидация ввода, предотвращение операций при пустых полях.

NUnitForms (историческая справка, .NET)
- NUnitForms — расширение для NUnit (C# WinForms), позволяющее находить контролы по имени и симулировать события (Click, Change). Поддерживает ожидания и утверждения для состояний форм.
- Актуальность: проект устарел, но важен как пример подхода к автоматизации настольных UI.
- Аналоги в мире Java: AssertJ-Swing, FEST-Swing (устар.), Jemmy, Abbot; для JavaFX — TestFX; для веб — Selenium/WebDriver.

Coded UI (историческая справка, .NET)
- Microsoft Coded UI Tests (Visual Studio) предоставляли запись/воспроизведение сценариев UI с автогенерацией UIMap. Официально сняты с поддержки (deprecated).
- Концепции: рекордер, маппинг контролов, устойчивость к изменению интерфейса, высокая трудоемкость поддержки.
- Современные альтернативы: Playwright/Watir/Selenium для веб; для desktop — WinAppDriver/Appium/White (Windows). Для Java Swing чаще используют AssertJ-Swing или тестирование через API View.

Практические советы по GUI-тестам (Swing)
- Всегда выполняйте изменения UI на EDT. Для тестов — оборачивайте действия в invokeAndWait, если требуется синхронизация.
- Избегайте Thread.sleep; используйте события и синхронизацию.
- Разделяйте ответственность: View тонкий, Presenter содержит логику реакции.
- Для CI — отключайте тяжелые визуальные эффекты и, по возможности, используйте headless.

---

Лабораторная №4. Интеграция и исполняемая спецификация (BDD/Spec by Example)

Разработка, управляемая поведением (BDD)
- Идея: описывать поведение системы на языке домена через сценарии Given-When-Then, согласованные бизнесом, QA и разработчиками («Three Amigos»).
- Польза: общее понимание требований, трассировка «требование → тест», живущая документация, снижение разночтений.
- Инструменты: Cucumber/JBehave/SpecFlow (Gherkin), но BDD-вариант можно реализовать и «ручными» E2E-тестами с говорящими именами.

Спецификация на основе примеров (Specification by Example)
- Примеры (таблицы, сценарии) — первичный артефакт требований; тесты выполняют эти примеры, подтверждая соответствие.
- Цикл: совместная выработка примеров → автоматизация → непрерывная регрессия.
- В нашем проекте: E2E-тесты, оформленные как пользовательские сценарии (ввод значений, клик по кнопке, ожидание результата/ошибки), выступают такой спецификацией.

Интеграционные и E2E тесты: отличия и советы
- Интеграционные: проверяют взаимодействие нескольких реальных компонент (Presenter+Calculator+простая View), без внешних систем.
- E2E: проверяют сквозной пользовательский поток (полный стек приложения).
- Практика: уменьшайте скрытую глобальную статику, предоставляйте точки расширения (инъекция зависимостей) для контроля окружения, стабилизируйте UI-события.

Полезная теория (ЛР №4)
- Пирамида тестирования: много Unit, меньше Integration, еще меньше E2E — баланс скорости/стоимости/полезности.
- Нефункциональные аспекты на уровне интеграции: стабильность, сообщения об ошибках, отзывчивость UI.
- Трассируемость: таблица mapping «сценарий → тест → класс», отчеты CI, JaCoCo для видимости покрытий.

---

Краткий глоссарий
- Unit test — изолированный тест отдельного класса/метода.
- Integration test — тест нескольких компонент вместе.
- E2E test — сквозной пользовательский сценарий.
- Mock/Stub/Fake/Spy — виды тестовых двойников.
- BDD — подход описания поведения через сценарии на языке домена.
- Coverage — метрики покрытия (инструкции, ветвления, методы, классы).

Рекомендуемые ссылки
- JUnit 5 User Guide: https://junit.org/junit5/docs/current/user-guide/
- Mockito: https://site.mockito.org/
- JaCoCo: https://www.jacoco.org/jacoco/
- AssertJ-Swing: https://joel-costigliola.github.io/assertj/assertj-swing.html
- Cucumber (BDD): https://cucumber.io/docs/guides/overview/

