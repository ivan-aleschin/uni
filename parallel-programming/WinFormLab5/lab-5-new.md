## Лабораторная работа №5
### Параллельные алгоритмы сортировки и умножения матриц

**Дисциплина:** Теория параллельного программирования

**Выполнил:**
- Алешин Иван Кириллович

**Группа:** ПИН-31

**Дата:** 26.01.2026

**Подпись:** _______________

---

## Аннотация

Реализованы и исследованы три параллельных алгоритма: сортировка чёт-нечёт (Odd-Even Sort), умножение матриц методом Кэннона и ленточным методом. Программа демонстрирует различные подходы к параллельной обработке данных и позволяет сравнить их эффективность при различном количестве потоков.

---

## Содержание

1. [[#1. Назначение и условия применения|Назначение и условия применения]]
2. [[#2. Описание алгоритма|Описание алгоритма]]
3. [[#3. Используемые технологии программирования|Используемые технологии программирования]]
4. [[#4. Входные и выходные данные|Входные и выходные данные]]
5. [[#5. Результаты тестирования|Результаты тестирования]]

---

## 1. Назначение и условия применения

### 1.1 Назначение программы

Программа предназначена для демонстрации и сравнения параллельных алгоритмов сортировки и умножения матриц. Позволяет исследовать производительность различных методов параллельной обработки данных и изучить влияние количества потоков на эффективность вычислений.

### 1.2 Функции, выполняемые программой

- Параллельная сортировка строк матрицы методом чёт-нечёт (Odd-Even Sort)
- Параллельное умножение матриц методом Кэннона с блочной декомпозицией
- Параллельное умножение матриц ленточным методом с горизонтальным разбиением
- Измерение времени выполнения каждого алгоритма
- Сравнение производительности при различном числе потоков

### 1.3 Условия, необходимые для выполнения программы

**Требования к аппаратному обеспечению:**
- Процессор: AMD Ryzen 5 4500U или аналогичный многоядерный процессор
- Оперативная память: минимум 8 ГБ (рекомендуется 16 ГБ)

**Требования к программному обеспечению:**
- Операционная система: Windows 10/11 (x64)
- Среда выполнения: .NET 9.0 Runtime
- Библиотеки: System.Threading.Tasks

**Требования к персоналу:**
- Базовые навыки работы с Windows
- Понимание принципов параллельного программирования

---

## 2. Описание алгоритма

### 2.1 Постановка задачи

**Задача 1: Сортировка матрицы**
Дана матрица M[N][N]. Требуется отсортировать каждую строку по возрастанию.

**Задача 2: Умножение матриц**
Даны матрицы A[N][N] и B[N][N]. Требуется вычислить C = A × B, где:
```
C[i][j] = ∑(k=0 to N-1) A[i][k] × B[k][j]
```

### 2.2 Алгоритм чёт-нечёт сортировки (Odd-Even Sort)

Параллельная версия пузырьковой сортировки с разделением на чётные и нечётные фазы.
```csharp
void OddEvenSort(int[,] matrix, int N, int threads) {
    for (int phase = 0; phase < N; phase++) {
        if (phase % 2 == 0) {
            // Чётная фаза: сравниваем пары (0,1), (2,3), (4,5), ...
            Parallel.For(0, N / 2, new ParallelOptions { MaxDegreeOfParallelism = threads }, 
                i => {
                    int idx = 2 * i;
                    if (matrix[row, idx] > matrix[row, idx + 1]) {
                        Swap(ref matrix[row, idx], ref matrix[row, idx + 1]);
                    }
                });
        } else {
            // Нечётная фаза: сравниваем пары (1,2), (3,4), (5,6), ...
            Parallel.For(0, (N - 1) / 2, new ParallelOptions { MaxDegreeOfParallelism = threads },
                i => {
                    int idx = 2 * i + 1;
                    if (matrix[row, idx] > matrix[row, idx + 1]) {
                        Swap(ref matrix[row, idx], ref matrix[row, idx + 1]);
                    }
                });
        }
    }
}
```

**Принцип работы:**
```
Массив: [5, 2, 8, 1, 9, 3]

Фаза 0 (чётная): сравниваем (5,2), (8,1), (9,3) параллельно
Результат:       [2, 5, 1, 8, 3, 9]

Фаза 1 (нечётная): сравниваем (5,1), (8,3) параллельно
Результат:         [2, 1, 5, 3, 8, 9]

Фаза 2 (чётная): сравниваем (2,1), (5,3), (8,9) параллельно
Результат:       [1, 2, 3, 5, 8, 9]

...продолжается до полной сортировки
```

**Характеристики:**
- Количество фаз: N
- Сложность: O(N²) операций сравнения
- Параллелизм: до N/2 операций одновременно

### 2.3 Метод Кэннона

Блочный параллельный алгоритм умножения матриц с циклическим сдвигом блоков.

**Декомпозиция:**
Матрицы делятся на блоки размером B×B. Процесс организован как √P × √P сетка процессов.
```csharp
void CannonMethod(int[,] A, int[,] B, int[,] C, int N, int P) {
    int gridSize = (int)Math.Sqrt(P);  // √P × √P сетка процессов
    int blockSize = N / gridSize;
    
    // Инициализация: циклический сдвиг блоков A и B
    InitialShift(A, B, gridSize, blockSize);
    
    // Основной цикл: gridSize итераций
    for (int step = 0; step < gridSize; step++) {
        // Параллельное умножение соответствующих блоков
        Parallel.For(0, P, p => {
            int i = p / gridSize;
            int j = p % gridSize;
            MultiplyBlock(A, B, C, i, j, blockSize);
        });
        
        // Циклический сдвиг блоков
        ShiftBlocks(A, B, gridSize, blockSize);
    }
}
```

**Схема работы для 4 процессов (2×2 сетка):**
```
Инициализация:
A: блоки сдвинуты влево на i позиций
B: блоки сдвинуты вверх на j позиций

Шаг 0: умножение блоков A[i,j] × B[i,j]
Шаг 1: сдвиг A влево, B вверх, затем умножение
...
```

**Характеристики:**
- Количество итераций: √P
- Операций на блок: B³
- Общая сложность: O(N³/P)

### 2.4 Ленточный метод

Горизонтальное разбиение матрицы A на ленты (полосы строк).
```csharp
void TapeMethod(int[,] A, int[,] B, int[,] C, int N, int threads) {
    int rowsPerThread = N / threads;
    
    Parallel.For(0, threads, t => {
        int startRow = t * rowsPerThread;
        int endRow = (t == threads - 1) ? N : startRow + rowsPerThread;
        
        for (int i = startRow; i < endRow; i++) {
            for (int j = 0; j < N; j++) {
                int sum = 0;
                for (int k = 0; k < N; k++) {
                    sum += A[i, k] * B[k, j];
                }
                C[i, j] = sum;
            }
        }
    });
}
```

**Схема распределения (P=4):**
```
Матрица A разбита на горизонтальные полосы:

Поток 0: строки [0 .. N/4-1]
Поток 1: строки [N/4 .. N/2-1]
Поток 2: строки [N/2 .. 3N/4-1]
Поток 3: строки [3N/4 .. N-1]

Каждый поток читает всю матрицу B
```

**Характеристики:**
- Каждый поток обрабатывает N/P строк
- Сложность на поток: O(N³/P)
- Требует дублирования матрицы B

---

## 3. Используемые технологии программирования

### 3.1 Язык и платформа

- Язык: C# 12
- Платформа: .NET 9.0
- Целевая платформа: net9.0-windows

### 3.2 Фреймворки и библиотеки

**Многопоточность:**
- `System.Threading.Tasks.Parallel` — параллельные циклы
- `ParallelOptions` — управление количеством потоков

**UI:**
- `System.Windows.Forms` — графический интерфейс

### 3.3 Структуры данных

- Матрицы: двумерные массивы `int[,]`
- Классы-обёртки: `OddEvenSort`, `CannonMethod`, `TapeMethod`
- `Stopwatch` — замер времени выполнения

### 3.4 Особенности реализации

**Разделение данных:**
- Odd-Even Sort: независимые пары элементов на каждой фазе
- Cannon: блочная декомпозиция с циклическими сдвигами
- Tape: горизонтальные полосы без пересечений

**Синхронизация:**
- Отсутствие гонок данных за счёт разделения областей записи
- Барьеры между фазами в Odd-Even Sort
- Независимые вычисления в Tape Method

---

## 4. Входные и выходные данные

### 4.1 Входные данные

**Формат:**
Параметры задаются через графический интерфейс:
- Размер матрицы N (целое число)
- Количество потоков P (целое число)
- Выбор алгоритма

**Пример:**
```
Размер матрицы: 512
Количество потоков: 4
Алгоритм: CannonMethod
```

### 4.2 Выходные данные

**Формат:**
- Результирующая матрица (или отсортированная матрица)
- Время выполнения
- Ускорение (Speedup)
- Эффективность

**Пример:**
```
Время выполнения: 0.45 сек
Ускорение: 3.2×
Эффективность: 80%
```

### 4.3 Запуск программы

**Сборка:**
```powershell
dotnet build -c Release
```

**Запуск:**
```powershell
.\bin\Release\net9.0-windows\WinFormLab5.exe
```

---

## 5. Результаты тестирования

### 5.1 Конфигурация тестовой системы

**Аппаратная конфигурация:**
- Процессор: AMD Ryzen 5 4500U (6 ядер, 2.3-4.0 ГГц)
- Оперативная память: 16 ГБ DDR4 2666 МГц

**Программная конфигурация:**
- ОС: Windows 11 Pro
- .NET Runtime: 9.0.1
- Конфигурация: Release (x64)

### 5.2 Функциональное тестирование

**Тест 1: Сортировка матрицы 128×128 (Odd-Even Sort)**
- Входные данные: матрица 128×128 случайных чисел, 2 потока
- Ожидаемый результат: каждая строка отсортирована по возрастанию
- Результат: все строки отсортированы корректно
- Статус: ✓ Пройден

**Тест 2: Умножение матриц 256×256 (Cannon Method)**
- Входные данные: две матрицы 256×256, 4 потока
- Метод проверки: сравнение с эталонным результатом
- Результат: совпадает с эталоном
- Статус: ✓ Пройден

**Тест 3: Умножение матриц 512×512 (Tape Method)**
- Входные данные: две матрицы 512×512, 4 потока
- Метод проверки: сравнение с эталонным результатом
- Результат: совпадает с эталоном
- Статус: ✓ Пройден

**Тест 4: Корректность при P=1**
- Описание: проверка работы при одном потоке
- Результат: все алгоритмы работают корректно
- Статус: ✓ Пройден

**Тест 5: Граничные случаи (малые матрицы)**
- Описание: матрицы 4×4, 8×8
- Результат: корректная обработка
- Статус: ✓ Пройден

### 5.3 Тестирование производительности

**Odd-Even Sort (матрица 1024×1024, усреднение по 10 итерациям):**

| Потоки | Время (сек) | Ускорение | Эффективность |
|--------|-------------|-----------|---------------|
| 1      | 8.50        | 1.0×      | 100%          |
| 2      | 4.80        | 1.8×      | 89%           |
| 4      | 2.90        | 2.9×      | 73%           |
| 6      | 2.30        | 3.7×      | 62%           |

**Cannon Method (усреднение по 5 итерациям):**

| Размер | Потоки | Время (сек) | Ускорение | Эффективность |
|--------|--------|-------------|-----------|---------------|
| 256×256| 1      | 0.35        | 1.0×      | 100%          |
| 256×256| 4      | 0.12        | 2.9×      | 73%           |
| 512×512| 1      | 2.80        | 1.0×      | 100%          |
| 512×512| 4      | 0.95        | 2.9×      | 73%           |
| 1024×1024| 1    | 24.5        | 1.0×      | 100%          |
| 1024×1024| 4    | 7.8         | 3.1×      | 78%           |

**Tape Method (усреднение по 5 итерациям):**

| Размер | Потоки | Время (сек) | Ускорение | Эффективность |
|--------|--------|-------------|-----------|---------------|
| 256×256| 1      | 0.32        | 1.0×      | 100%          |
| 256×256| 4      | 0.10        | 3.2×      | 80%           |
| 512×512| 1      | 2.55        | 1.0×      | 100%          |
| 512×512| 2      | 1.35        | 1.9×      | 95%           |
| 512×512| 4      | 0.79        | 3.2×      | 80%           |
| 512×512| 6      | 0.62        | 4.1×      | 68%           |
| 1024×1024| 4    | 6.5         | —         | —             |

### 5.4 Выводы по результатам тестирования

1. **Корректность:** Все алгоритмы дают правильные результаты. Граничные случаи обрабатываются корректно.

2. **Odd-Even Sort:**
    - Хорошая масштабируемость до 4 потоков
    - Эффективность снижается при P>4 из-за накладных расходов на синхронизацию
    - Подходит для сортировки независимых строк матрицы

3. **Cannon Method:**
    - Стабильная эффективность ~73-78% на различных размерах
    - Требует размер матрицы кратный √P
    - Эффективен для больших матриц (N≥512)

4. **Tape Method:**
    - Лучшая масштабируемость среди методов умножения
    - Эффективность 80-95% при 2-4 потоках
    - Простота реализации
    - Требует больше памяти (дублирование B)

5. **Сравнение методов умножения:**
    - Для N<512: Tape Method эффективнее
    - Для N≥512: оба метода показывают схожую производительность
    - Cannon более сложен в реализации, но лучше масштабируется теоретически

6. **Практические рекомендации:**
    - Оптимальное количество потоков: 4 для данной системы
    - Для сортировки: использовать Odd-Even Sort при P≤4
    - Для умножения малых матриц: Tape Method
    - Для умножения больших матриц: любой метод, Tape проще

---

## Список использованных источников

1. Гергель В.П. Теория и практика параллельных вычислений. Учебное пособие
2. Методические указания к лабораторным работам по курсу "Теория параллельного программирования"