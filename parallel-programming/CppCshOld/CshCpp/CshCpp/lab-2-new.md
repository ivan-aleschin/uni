## Лабораторная работа №2
### Использование SSE-инструкций для параллельного сложения массивов и матриц

**Дисциплина:** Теория параллельного программирования

**Выполнил:**
- Алешин Иван Кириллович

**Группа:** ПИН-31

**Дата:** 26.01.2026

**Подпись:** _______________

---

## Аннотация

Реализована библиотека на C++ с использованием SSE-инструкций для векторизованного сложения массивов и матриц с элементами типа float. Программа демонстрирует применение SIMD-технологий для ускорения вычислений и позволяет сравнить производительность скалярной и векторной реализаций на различных объёмах данных.

---

## Содержание

1. [[#1. Назначение и условия применения|Назначение и условия применения]]
2. [[#2. Описание алгоритма|Описание алгоритма]]
3. [[#3. Используемые технологии программирования|Используемые технологии программирования]]
4. [[#4. Входные и выходные данные|Входные и выходные данные]]
5. [[#5. Результаты тестирования|Результаты тестирования]]

---

## 1. Назначение и условия применения

### 1.1 Назначение программы

Программа предназначена для демонстрации применения технологии SIMD (Single Instruction Multiple Data) на примере SSE-инструкций процессора для параллельной обработки данных. Реализует операции поэлементного сложения массивов и матриц с использованием векторных регистров XMM, что позволяет обрабатывать 4 элемента типа float за одну инструкцию.

### 1.2 Функции, выполняемые программой

- Поэлементное сложение двух одномерных массивов типа float
- Поэлементное сложение двух матриц типа float (размерности кратны 4)
- Сравнение производительности скалярной и векторной реализаций
- Верификация корректности результатов векторных операций

### 1.3 Условия, необходимые для выполнения программы

**Требования к аппаратному обеспечению:**
- Процессор: AMD Ryzen 5 4500U или Intel с поддержкой SSE
- Оперативная память: минимум 4 ГБ (рекомендуется 8 ГБ)

**Требования к программному обеспечению:**
- Операционная система: Windows 10/11 (x64)
- Компилятор C++: Microsoft Visual C++ 2022
- Среда выполнения: .NET 9.0 Runtime

**Требования к персоналу:**
- Понимание принципов SIMD
- Знание C++/C# и работы с P/Invoke

---

## 2. Описание алгоритма

### 2.1 Постановка задачи

Необходимо реализовать операцию поэлементного сложения двух массивов A и B с результатом в массиве C:
```
C[i] = A[i] + B[i], где i = 0..N-1
```

Требования:
- Размер массива N кратен 4
- Все элементы имеют тип float (32 бита)

### 2.2 Скалярный алгоритм
```cpp
void AddArraysScalar(float* A, float* B, float* C, int N) {
    for (int i = 0; i < N; i++) {
        C[i] = A[i] + B[i];
    }
}
```

**Характеристики:**
- Обработка по одному элементу за итерацию
- Количество итераций: N

### 2.3 Векторный алгоритм (SSE)

SSE позволяет использовать 128-битные регистры XMM для одновременной обработки 4 элементов типа float.
```cpp
void AddArraysSSE(float* A, float* B, float* C, int N) {
    for (int i = 0; i < N; i += 4) {
        // Загрузка 4 элементов из A
        __m128 vecA = _mm_loadu_ps(&A[i]);
        
        // Загрузка 4 элементов из B
        __m128 vecB = _mm_loadu_ps(&B[i]);
        
        // Параллельное сложение 4 пар
        __m128 vecC = _mm_add_ps(vecA, vecB);
        
        // Сохранение результата
        _mm_storeu_ps(&C[i], vecC);
    }
}
```

**Принцип работы одной итерации:**
```
Обрабатываются индексы i, i+1, i+2, i+3:

XMM0 ← [A[i], A[i+1], A[i+2], A[i+3]]
XMM1 ← [B[i], B[i+1], B[i+2], B[i+3]]

Параллельное сложение (одна инструкция):
XMM2 = XMM0 + XMM1

[C[i], C[i+1], C[i+2], C[i+3]] ← XMM2
```

**Характеристики:**
- Обработка по 4 элемента за итерацию
- Количество итераций: N/4
- Теоретическое ускорение: до 4×

### 2.4 Архитектура решения
```
C# Application (CshCpp.exe)
    ↓ P/Invoke
Native C++ DLL (CppAP.dll)
    ├─ AddArraysScalar()
    ├─ AddArraysSSE()
    ├─ AddMatricesScalar()
    └─ AddMatricesSSE()
```

---

## 3. Используемые технологии программирования

### 3.1 Язык и платформа

**Клиентская часть:**
- Язык: C# 12
- Платформа: .NET 9.0

**Вычислительная библиотека:**
- Язык: C++17
- Компилятор: MSVC 2022

### 3.2 Фреймворки и библиотеки

**SSE Intrinsics:**
- `_mm_loadu_ps()` — загрузка 4 float в XMM-регистр
- `_mm_add_ps()` — параллельное сложение 4 пар float
- `_mm_storeu_ps()` — сохранение 4 float из XMM-регистра

**P/Invoke:**
```csharp
[DllImport("CppAP.dll", CallingConvention = CallingConvention.Cdecl)]
public static extern void AddArraysSSE(
    [In] float[] A, 
    [In] float[] B, 
    [Out] float[] C, 
    int N
);
```

### 3.3 Структуры данных

- Массивы: `float[]` размером кратным 4
- Матрицы: одномерный массив `float[]` размером M×N (row-major order)

### 3.4 Особенности реализации

- Экспорт функций из DLL через `extern "C" __declspec(dllexport)`
- Автоматический маршалинг массивов C# в нативные указатели
- Флаги компиляции: `/O2 /arch:SSE2`

---

## 4. Входные и выходные данные

### 4.1 Входные данные

**Формат:**
- Два массива типа float
- Размер: N элементов (N % 4 == 0)

**Пример:**
```
A = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]
B = [0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5]
```

### 4.2 Выходные данные

**Формат:**
- Результирующий массив типа float

**Пример:**
```
C = [1.5, 3.5, 5.5, 7.5, 9.5, 11.5, 13.5, 15.5]
```

### 4.3 Запуск программы

**Сборка C++ библиотеки:**
```powershell
# В Visual Studio: Build → Build Solution (Release | x64)
# Или через MSBuild:
msbuild CppAP.sln /p:Configuration=Release /p:Platform=x64
```

**Сборка C# приложения:**
```powershell
cd C:\Dev\Workspace\CshCpp

dotnet build -c Release

# Копирование DLL
Copy-Item ".\CppAP\x64\Release\CppAP.dll" `
          ".\bin\Release\net9.0-windows\CppAP.dll"
```

**Запуск:**
```powershell
.\bin\Release\net9.0-windows\CshCpp.exe
```

---

## 5. Результаты тестирования

### 5.1 Конфигурация тестовой системы

**Аппаратная конфигурация:**
- Процессор: AMD Ryzen 5 4500U (6 ядер, 2.3-4.0 ГГц)
- Оперативная память: 16 ГБ DDR4 2666 МГц
- Накопитель: NVMe SSD

**Программная конфигурация:**
- ОС: Windows 11 Pro
- Компилятор: MSVC v143
- Флаги: `/O2 /arch:SSE2 /favor:AMD64`
- .NET Runtime: 9.0.1

### 5.2 Функциональное тестирование

**Тест 1: Минимальный размер (4 элемента)**
- Входные данные: A = [1.0, 2.0, 3.0, 4.0], B = [5.0, 6.0, 7.0, 8.0]
- Ожидаемый результат: C = [6.0, 8.0, 10.0, 12.0]
- Полученный результат: C = [6.0, 8.0, 10.0, 12.0]
- Статус: ✓ Пройден

**Тест 2: Малый массив (8 элементов)**
- Входные данные: A = [1,2,3,4,5,6,7,8], B = [8,7,6,5,4,3,2,1]
- Ожидаемый результат: C = [9,9,9,9,9,9,9,9]
- Полученный результат: все элементы = 9.0
- Статус: ✓ Пройден

**Тест 3: Средний массив (1024 элемента)**
- Входные данные: случайные float в [0.0, 100.0]
- Метод проверки: поэлементное сравнение с допуском 1e-6
- Статус: ✓ Пройден (все элементы совпадают)

**Тест 4: Большой массив (1 000 000 элементов)**
- Входные данные: случайные float в [-1000.0, 1000.0]
- Метод проверки: сравнение с эталоном
- Статус: ✓ Пройден (макс. расхождение < 1e-5)

**Тест 5: Матрица 256×256**
- Входные данные: случайные float
- Метод проверки: сравнение с эталоном
- Статус: ✓ Пройден

### 5.3 Тестирование производительности

**Массивы (усреднение по 100 итерациям):**

| Размер | Скалярная (мс) | SSE (мс) | Ускорение | Эффективность |
|--------|----------------|----------|-----------|---------------|
| 4      | 0.00008        | 0.00015  | 0.53×     | 13%           |
| 8      | 0.00012        | 0.00018  | 0.67×     | 17%           |
| 64     | 0.0008         | 0.0006   | 1.33×     | 33%           |
| 256    | 0.0035         | 0.0021   | 1.67×     | 42%           |
| 1 024  | 0.012          | 0.0052   | 2.31×     | 58%           |
| 16 384 | 0.19           | 0.065    | 2.92×     | 73%           |
| 65 536 | 0.78           | 0.25     | 3.12×     | 78%           |
| 1M     | 13.5           | 3.9      | 3.46×     | 87%           |
| 4M     | 56.0           | 15.8     | 3.54×     | 89%           |

**Матрицы (усреднение по 100 итерациям):**

| Размер    | Элементов | Скалярная (мс) | SSE (мс) | Ускорение |
|-----------|-----------|----------------|----------|-----------|
| 4×4       | 16        | 0.00028        | 0.00032  | 0.88×     |
| 64×64     | 4 096     | 0.052          | 0.021    | 2.48×     |
| 256×256   | 65 536    | 0.85           | 0.27     | 3.15×     |
| 1024×1024 | 1M        | 14.2           | 4.3      | 3.30×     |

### 5.4 Выводы по результатам тестирования

1. **Корректность:** Все функциональные тесты пройдены. SSE-реализация даёт идентичные результаты скалярной версии.

2. **Производительность:**
    - На малых данных (< 64): SSE медленнее из-за накладных расходов
    - На средних данных (256-64K): ускорение 1.5-3×
    - На больших данных (> 1M): стабильное ускорение ~3.5×

3. **Практические выводы:**
    - SSE эффективен для массивов > 256 элементов
    - Реальное ускорение (3.5×) меньше теоретического (4×) из-за ограничений памяти
    - При размере > 1M эффективность достигает 87-89%

4. **Рекомендации:**
    - Использовать SSE для больших объёмов данных
    - Для критичных задач рассмотреть AVX/AVX2 (8 float одновременно)
    - Учитывать накладные расходы при работе с малыми массивами

---

## Список использованных источников

1. Microsoft Docs — SIMD Extensions.
2. Microsoft Docs — Platform Invoke.
3. Методические указания к лабораторным работам по курсу "Теория параллельного программирования"