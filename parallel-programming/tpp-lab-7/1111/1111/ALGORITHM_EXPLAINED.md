# 🎨 ВИЗУАЛЬНОЕ ОБЪЯСНЕНИЕ АЛГОРИТМА

## 📊 Как работает Merge-Join с параллельным черпаком

### Исходные таблицы

#### Таблица A (неотсортированная)
```
┌──────────┬────┐
│    A     │ B  │
├──────────┼────┤
│ "KEY001" │ 5  │
│ "KEY003" │ 3  │
│ "KEY001" │ 7  │
│ "KEY002" │ 2  │
│ "KEY001" │ 9  │
│ "KEY002" │ 4  │
└──────────┴────┘
```

#### Таблица B (неотсортированная)
```
┌──────────┬────┐
│    A     │ C  │
├──────────┼────┤
│ "KEY002" │ 10 │
│ "KEY001" │ 6  │
│ "KEY003" │ 8  │
│ "KEY001" │ 12 │
└──────────┴────┘
```

---

### ШАГ 1: Сортировка (TableSorter.CreateSortedCopies)

#### Asrt (отсортированная A)
```
┌──────────┬────┐
│    A     │ B  │
├──────────┼────┤
│ "KEY001" │ 5  │  ┐
│ "KEY001" │ 7  │  ├─ Группа "KEY001"
│ "KEY001" │ 9  │  ┘
│ "KEY002" │ 2  │  ┐ Группа "KEY002"
│ "KEY002" │ 4  │  ┘
│ "KEY003" │ 3  │  ← Группа "KEY003"
└──────────┴────┘
```

#### Bsrt (отсортированная B)
```
┌──────────┬────┐
│    A     │ C  │
├──────────┼────┤
│ "KEY001" │ 6  │  ┐ Группа "KEY001"
│ "KEY001" │ 12 │  ┘
│ "KEY002" │ 10 │  ← Группа "KEY002"
│ "KEY003" │ 8  │  ← Группа "KEY003"
└──────────┴────┘
```

---

### ШАГ 2: Merge-Join с черпаком

#### Итерация 1: Обработка "KEY001"

**1. Scoop() - Черпаем из Asrt:**
```
bucket.Key = "KEY001"
bucket.Bs = [5, 7, 9]  ← Все B для "KEY001"
          ┌───┐
          │ 5 │
          │ 7 │ ← Черпак!
          │ 9 │
          └───┘
```

**2. Читаем первую строку из Bsrt:**
```
keyB = "KEY001", C = 6
```

**3. Сравниваем: bucket.Key ("KEY001") == keyB ("KEY001") ✅**

**4. ПАРАЛЛЕЛЬНО вычисляем:**
```
        Черпак [5, 7, 9] × C = 6
              ↓
    ┌─────────┼─────────┐
    │         │         │
Поток 1   Поток 2   Поток 3
5 × 6     7 × 6     9 × 6
= 30      = 42      = 54
    │         │         │
    └─────────┼─────────┘
              ↓
         lock(lockObj)
    localSum = 30+42+54 = 126
```

**5. Читаем следующую строку из Bsrt:**
```
keyB = "KEY001", C = 12
```

**6. Снова параллельно:**
```
        Черпак [5, 7, 9] × C = 12
              ↓
    ┌─────────┼─────────┐
    │         │         │
Поток 1   Поток 2   Поток 3
5 × 12    7 × 12    9 × 12
= 60      = 84      = 108
    │         │         │
    └─────────┼─────────┘
              ↓
         lock(lockObj)
    localSum = 60+84+108 = 252
```

**7. Суммируем для "KEY001":**
```
currentSum = 126 + 252 = 378
```

**8. Записываем результат:**
```
┌──────────┬────────┐
│    A     │  sBC   │
├──────────┼────────┤
│ "KEY001" │  378   │
└──────────┴────────┘
```

---

#### Итерация 2: Обработка "KEY002"

**1. Scoop() - Новый черпак:**
```
bucket.Key = "KEY002"
bucket.Bs = [2, 4]  ← Черпак для "KEY002"
          ┌───┐
          │ 2 │ ← Черпак!
          │ 4 │
          └───┘
```

**2. Читаем из Bsrt:**
```
keyB = "KEY002", C = 10
```

**3. Параллельно:**
```
    Черпак [2, 4] × C = 10
          ↓
    ┌─────┴─────┐
    │           │
Поток 1     Поток 2
2 × 10      4 × 10
= 20        = 40
    │           │
    └─────┬─────┘
          ↓
    localSum = 60
```

**4. Результат для "KEY002":**
```
┌──────────┬────────┐
│    A     │  sBC   │
├──────────┼────────┤
│ "KEY001" │  378   │
│ "KEY002" │   60   │
└──────────┴────────┘
```

---

#### Итерация 3: Обработка "KEY003"

**1. Scoop():**
```
bucket.Key = "KEY003"
bucket.Bs = [3]  ← Черпак с одним элементом
          ┌───┐
          │ 3 │ ← Черпак!
          └───┘
```

**2. Читаем из Bsrt:**
```
keyB = "KEY003", C = 8
```

**3. Вычисляем:**
```
Черпак [3] × C = 8
       ↓
   Поток 1
   3 × 8
   = 24
```

**4. Финальный результат:**
```
┌──────────┬────────┐
│    A     │  sBC   │
├──────────┼────────┤
│ "KEY001" │  378   │
│ "KEY002" │   60   │
│ "KEY003" │   24   │
└──────────┴────────┘
```

---

## 🔄 Алгоритм Merge-Join (застёжка-молния)

```
Asrt (указатель →)          Bsrt (указатель →)
┌──────────┬────┐           ┌──────────┬────┐
│ "KEY001" │ 5  │  ←┐       │ "KEY001" │ 6  │  ←┐
│ "KEY001" │ 7  │   │       │ "KEY001" │ 12 │   │
│ "KEY001" │ 9  │   │       ├──────────┼────┤   │
├──────────┼────┤   │       │ "KEY002" │ 10 │   │
│ "KEY002" │ 2  │   │       ├──────────┼────┤   │
│ "KEY002" │ 4  │   │       │ "KEY003" │ 8  │   │
├──────────┼────┤   │       └──────────┴────┘   │
│ "KEY003" │ 3  │   │                            │
└──────────┴────┘   │                            │
        │            │                            │
        └────────────┴────────────────────────────┘
                     │
               Сравниваем ключи
                     │
        ┌────────────┴────────────┐
        │                         │
   KEY_A < KEY_B            KEY_A == KEY_B
    Scoop() →               ┌─────────┴─────────┐
    Новый черпак            │                   │
                       Параллельно          KEY_A > KEY_B
                       обрабатываем         readB.Read() →
                       черпак               Следующая строка B
                            │
                       Записываем
                       результат
```

---

## 🧠 Ключевые концепции

### 1. Черпак (Bucket)
```
╔═══════════════════════════════╗
║         ЧЕРПАК                ║
║  ┌─────────────────────────┐  ║
║  │ Key: "KEY001"           │  ║
║  │ Bs: [5, 7, 9]           │  ║
║  └─────────────────────────┘  ║
║                               ║
║  Содержит ВСЕ строки с        ║
║  одинаковым ключом из         ║
║  таблицы A                    ║
╚═══════════════════════════════╝
```

### 2. Параллельная обработка черпака
```
         ПОСЛЕДОВАТЕЛЬНО              |        ПАРАЛЛЕЛЬНО
                                      |
    foreach (int bVal in bucket.Bs)   |   Parallel.ForEach(bucket.Bs, bVal =>
    {                                 |   {
        localSum += bVal * cVal;      |       double prod = bVal * cVal;
    }                                 |       lock (lockObj)
                                      |       {
    Время: O(n)                       |           localSum += prod;
    1 поток                           |       }
    Медленно                          |   });
                                      |
                                      |   Время: O(n/p) где p = кол-во ядер
                                      |   Несколько потоков
                                      |   Быстро! ⚡
```

### 3. Синхронизация через lock
```
    Поток 1         Поток 2         Поток 3
       │               │               │
       ├──► prod=30    ├──► prod=42    ├──► prod=54
       │               │               │
       ↓               ↓               ↓
    ┌─────────────────────────────────────┐
    │       lock (lockObj)                │
    │   ┌─────────────────────────────┐   │
    │   │   localSum += prod;         │   │  ← Критическая секция
    │   │                             │   │    (только 1 поток за раз!)
    │   └─────────────────────────────┘   │
    └─────────────────────────────────────┘
                     │
                     ↓
            localSum = 126 ✅
```

**БЕЗ lock:**
```
localSum = 0
Поток 1: читает 0, прибавляет 30, пишет 30
Поток 2: читает 0, прибавляет 42, пишет 42  ← Перезаписал!
Поток 3: читает 42, прибавляет 54, пишет 96
                                        ↓
                         Результат: 96 ❌ (Должно быть 126!)
```

---

## 📈 Производительность

### Размер черпака влияет на эффективность параллелизма

```
Черпак: [B₁]               Черпак: [B₁, B₂, ..., B₁₀₀]
     ↓                              ↓
1 элемент                    100 элементов
     ↓                              ↓
Параллелизм                  Параллелизм
неэффективен                 очень эффективен!
     ↓                              ↓
Накладные расходы >          Накладные расходы <<
выигрыш                      выигрыш
```

### Speedup (ускорение)

```
Speedup = Время_последовательное / Время_параллельное

Идеальный случай (4 ядра):
Speedup = 4.0 (линейное ускорение)

Реальность:
Speedup ≈ 2.5 - 3.0 (из-за накладных расходов на синхронизацию)
```

---

## 🎓 Вопросы для самопроверки

### Вопрос 1: Что произойдёт, если не сортировать таблицы?
<details>
<summary>Ответ</summary>

Merge-Join не будет работать корректно! Алгоритм предполагает, что обе таблицы отсортированы по ключу. Без сортировки придётся использовать вложенные циклы (O(n²) вместо O(n+m)).
</details>

### Вопрос 2: Зачем нужен lock в параллельной версии?
<details>
<summary>Ответ</summary>

Чтобы избежать race condition при суммировании. Несколько потоков одновременно пытаются изменить `localSum`. Без lock результат будет неправильным (потеря части вычислений).
</details>

### Вопрос 3: Когда параллельная версия эффективнее последовательной?
<details>
<summary>Ответ</summary>

1. Когда черпак содержит много элементов (много строк с одинаковым ключом)
2. На многоядерных процессорах (4+ ядер)
3. Когда вычисления достаточно тяжёлые (в нашем случае - просто умножение, но если бы были сложные функции, выигрыш был бы больше)
</details>

### Вопрос 4: Что будет, если удалить Scoop() и обрабатывать строки по одной?
<details>
<summary>Ответ</summary>

Алгоритм всё равно будет работать, но:
1. Придётся для каждой строки из B сканировать все соответствующие строки из A
2. Потеряется возможность эффективной параллелизации (нечего распараллеливать)
3. Производительность ухудшится

Черпак - это оптимизация, которая группирует строки с одинаковым ключом и позволяет обработать их все разом (параллельно).
</details>

---

## ✅ Теперь вы понимаете!

- ✅ Как работает Merge-Join
- ✅ Что такое черпак и зачем он нужен
- ✅ Где происходит параллелизация
- ✅ Зачем нужен lock
- ✅ Почему нужна сортировка

**Готовы к запуску! 🚀**

См. также: `QUICKSTART.md` для инструкций по запуску.

