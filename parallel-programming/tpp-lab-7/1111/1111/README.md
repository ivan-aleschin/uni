# Лабораторная работа: Параллельная реализация Join и параллельный черпак

## 📋 Описание лабораторной работы

Эта лабораторная работа реализует **параллельную операцию JOIN** для двух таблиц базы данных с использованием алгоритма **Merge-Join** и концепции **"черпака"** (scoop).

### Цель работы
1. Реализовать собственную параллельную реализацию операции JOIN
2. Реализовать параллельный черпак для обработки данных

---

## 🏗️ Архитектура решения

### Основные компоненты:

#### 1. **Program.cs** - Главное меню
Консольное приложение с меню для управления всеми операциями:
- Создание таблиц A и B
- Генерация тестовых данных
- Сортировка таблиц
- Выполнение SQL JOIN (для сравнения)
- Выполнение Merge-Join (последовательно и параллельно)

#### 2. **MergeAB.cs** - Ядро параллельного Join
Это главный файл с реализацией параллельного JOIN через алгоритм Merge-Join.

**Ключевые концепции:**

##### 🪣 **Черпак (Scoop)** - метод `Scoop()`
```csharp
private bool Scoop()
{
    bucket.Bs = new List<int>();
    bucket.Key = null;

    if (!hasA)
        return false;

    string key = readA.GetString(0).TrimEnd();
    bucket.Key = key;

    // Собираем все строки с этим ключом
    do
    {
        int bVal = readA.GetInt32(1);
        bucket.Bs.Add(bVal);
        hasA = readA.Read();
    }
    while (hasA && readA.GetString(0).TrimEnd() == key);

    return true;
}
```

**Что делает черпак:**
- "Зачерпывает" из таблицы Asrt все строки с одинаковым ключом A
- Сохраняет все значения B для этого ключа в список `bucket.Bs`
- Это позволяет обработать все строки с одним ключом за один раз

##### 🔄 **Merge-Join алгоритм** - метод `MergeInternal(bool parallel)`

Алгоритм работает как "застежка-молния":
1. Читает отсортированные таблицы Asrt и Bsrt
2. Сравнивает ключи из обеих таблиц
3. При совпадении ключей:
   - Берет черпак из A (все B для ключа)
   - Умножает каждое B на текущее C из Bsrt
   - **Параллельно** (при parallel=true) вычисляет произведения

```csharp
if (parallel)
{
    object lockObj = new object();
    Parallel.ForEach(bucket.Bs, bVal =>
    {
        double prod = bVal * cVal;
        lock (lockObj)
        {
            localSum += prod;
        }
    });
}
else
{
    foreach (int bVal in bucket.Bs)
    {
        localSum += bVal * cVal;
    }
}
```

#### 3. **DbConfig.cs** - Конфигурация БД
Содержит строку подключения к SQL Server LocalDB.

#### 4. **DbSchema.cs** - Схема таблиц
Создает таблицы A и B с полями:
- **Таблица A**: A (ключ), B (число), D1, D2
- **Таблица B**: A (ключ), C (число), E1, E2

#### 5. **ABGenerator.cs** - Генератор данных
Генерирует тестовые данные с повторяющимися ключами.

#### 6. **TableSorter.cs** - Сортировщик
Создает отсортированные копии таблиц (Asrt, Bsrt) - необходимо для Merge-Join.

#### 7. **Benchmark.cs** - Бенчмаркинг
Замеряет производительность разных методов JOIN.

---

## 🔧 Установка и настройка SQL Server

### Вариант 1: LocalDB (рекомендуется для разработки)

**LocalDB уже установлен** вместе с Visual Studio 2017+.

#### Проверка установки LocalDB:
```powershell
# Проверить версии LocalDB
sqllocaldb versions

# Информация об инстансе MSSQLLocalDB
sqllocaldb info MSSQLLocalDB

# Если инстанс не создан, создать его:
sqllocaldb create MSSQLLocalDB

# Запустить инстанс:
sqllocaldb start MSSQLLocalDB
```

#### Строка подключения (уже в DbConfig.cs):
```csharp
@"Data Source=(localdb)\MSSQLLocalDB;Initial Catalog=LabAB;Integrated Security=True;"
```

### Вариант 2: SQL Server Express (если нужна полная версия)

#### Установка SQL Server Express:
1. Скачать: https://www.microsoft.com/en-us/sql-server/sql-server-downloads
2. Выбрать **SQL Server 2022 Express**
3. Установить с опциями по умолчанию

#### После установки измените DbConfig.cs:
```csharp
public const string ConnectionString =
    @"Server=localhost\SQLEXPRESS;Database=LabAB;Trusted_Connection=True;";
```

---

## 🚀 Запуск лабораторной работы

### 1. Восстановить NuGet пакеты
```powershell
cd C:\Dev\Workspace\tpp-lab-7\1111
dotnet restore
```

### 2. Собрать проект
```powershell
dotnet build
```

### 3. Запустить приложение
```powershell
dotnet run --project 1111/1111.csproj
```

---

## 📖 Пошаговая инструкция использования

После запуска программы вы увидите меню:

### Шаг 1: Создать таблицы
```
Выбор: 1
```
Создаются таблицы A и B в базе данных LabAB.

### Шаг 2: Сгенерировать данные
```
Выбор: 2
```
Генерируется 1000 уникальных ключей, каждый ключ повторяется 2-5 раз в каждой таблице.

### Шаг 3: Создать отсортированные копии
```
Выбор: 3
```
Создаются таблицы Asrt и Bsrt (отсортированные по ключу A).

### Шаг 4: Сравнить производительность

#### SQL JOIN (встроенный):
```
Выбор: 4
```
Выполняет стандартный SQL JOIN. Результат сохраняется в таблицу `AjB_sql`.

#### Merge-Join последовательный:
```
Выбор: 5
```
Выполняет кастомный Merge-Join БЕЗ параллелизма. Результат в `AjB_merge`.

#### Merge-Join параллельный:
```
Выбор: 6
```
Выполняет кастомный Merge-Join С параллелизмом. Результат в `AjB_merge`.

---

## 🧪 Как работает параллелизация

### Последовательная версия:
```csharp
foreach (int bVal in bucket.Bs)
{
    localSum += bVal * cVal;
}
```
- Обрабатывает каждое значение B последовательно
- Время: O(n)

### Параллельная версия:
```csharp
Parallel.ForEach(bucket.Bs, bVal =>
{
    double prod = bVal * cVal;
    lock (lockObj)
    {
        localSum += prod;
    }
});
```
- Распределяет вычисления по нескольким потокам
- Использует `lock` для синхронизации суммирования
- Время: O(n/p) где p - количество ядер

### Где именно параллелизуется:
Когда у ключа есть, например, 5 строк в таблице A (черпак содержит 5 значений B), и мы нашли совпадение в таблице B (значение C), нам нужно вычислить:
- B₁ × C
- B₂ × C
- B₃ × C
- B₄ × C
- B₅ × C

**Эти 5 умножений выполняются параллельно** на разных ядрах процессора!

---

## 🔍 Проверка результатов

### Через SQL Server Management Studio (SSMS):
1. Подключиться к `(localdb)\MSSQLLocalDB`
2. База данных: `LabAB`
3. Сравнить таблицы:

```sql
-- Результат SQL JOIN
SELECT * FROM AjB_sql ORDER BY A;

-- Результат Merge-Join
SELECT * FROM AjB_merge ORDER BY A;

-- Сравнение (должно быть пусто!)
SELECT A, sBC FROM AjB_sql
EXCEPT
SELECT A, sBC FROM AjB_merge;
```

---

## 🐛 Возможные проблемы и решения

### 1. **Ошибка: "Cannot open database LabAB"**
**Решение:**
- База создается автоматически при первом подключении
- Если нет, создайте вручную:
```sql
CREATE DATABASE LabAB;
```

### 2. **Ошибка: "A network-related or instance-specific error"**
**Решение:**
```powershell
# Запустить LocalDB
sqllocaldb start MSSQLLocalDB

# Или пересоздать инстанс
sqllocaldb stop MSSQLLocalDB
sqllocaldb delete MSSQLLocalDB
sqllocaldb create MSSQLLocalDB
sqllocaldb start MSSQLLocalDB
```

### 3. **Ошибка: "System.Data.SqlClient is obsolete"**
Это только предупреждение. Код работает, но можно мигрировать на `Microsoft.Data.SqlClient`:
```xml
<PackageReference Include="Microsoft.Data.SqlClient" Version="5.1.0" />
```

### 4. **Encoding warning в Benchmark.cs**
Это не критично, просто предупреждение о кодировке файла.

---

## 📊 Ожидаемые результаты производительности

На типичных данных (1000 ключей, 2-5 строк на ключ):

| Метод | Примерное время |
|-------|----------------|
| SQL JOIN | 50-200 мс |
| Merge-Join последовательный | 100-300 мс |
| Merge-Join параллельный | 80-200 мс |

**Параллельная версия быстрее последовательной** при большом количестве строк на ключ.

---

## 📚 Теоретические основы

### Merge-Join алгоритм
- **Сложность**: O(n + m) где n, m - размеры таблиц
- **Требование**: Обе таблицы отсортированы по ключу
- **Преимущество**: Эффективен для больших данных
- **Недостаток**: Требует предварительной сортировки

### Параллельный черпак
- **Черпак** - набор всех строк с одним ключом
- **Параллелизация** - обработка элементов черпака на разных ядрах
- **Критическая секция** - суммирование результатов (lock)

---

## 🎓 Вопросы для понимания

1. **Зачем нужна сортировка таблиц перед Merge-Join?**
   - Чтобы сканировать обе таблицы за один проход (O(n+m))

2. **Что такое "черпак" и почему он важен?**
   - Черпак собирает все строки с одним ключом из таблицы A
   - Позволяет обработать все комбинации (B × C) для одного ключа

3. **Почему нужен lock в параллельной версии?**
   - Несколько потоков одновременно суммируют результаты
   - Без lock возникнет race condition

4. **Когда параллельная версия эффективнее?**
   - Когда черпак содержит много элементов (много строк на ключ)
   - На многоядерных процессорах

---

## 📝 Задания для самостоятельной работы

1. **Увеличить объем данных:**
   - В Program.cs, case "2", изменить параметры:
   ```csharp
   ABGenerator.GenerateData(uniqueKeyCount: 10000, minRowsPerKey: 5, maxRowsPerKey: 20);
   ```

2. **Измерить ускорение:**
   - Запустить опции 5 и 6
   - Вычислить: Speedup = Time_Sequential / Time_Parallel

3. **Добавить параллелизацию на уровне черпаков:**
   - Сейчас черпаки обрабатываются последовательно
   - Можно распараллелить обработку нескольких черпаков

4. **Добавить вывод статистики:**
   - Количество обработанных ключей
   - Количество результирующих строк
   - Среднее количество строк в черпаке

---

## ✅ Готово к работе!

Код не содержит критических ошибок и готов к запуску. Следуйте инструкциям выше для выполнения лабораторной работы.

**Успехов в изучении параллельного программирования! 🚀**

