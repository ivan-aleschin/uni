# Лабораторная работа 1 — Вариант 1
## Синтаксис и основные типы данных Prolog

---

## Задание 1. `ball_volume(R, V)`

**Условие:** вычислить объём шара радиуса R. `ball_volume(1.0, V)` => `V = 4.18879...`

**Как работает:**
1. Принимаем радиус `R` и несвязанную переменную `V`
2. `is` вычисляет арифметическое выражение и унифицирует результат с `V`
3. `pi` — встроенная константа SWI-Prolog

**Описание:** Один предикат, одно правило. В Prolog нет возвращаемых значений — результат всегда передаётся через дополнительный аргумент. Здесь `V` и есть этот аргумент.

---

## Задание 2. `from_to(N, M, List)`

**Условие:** построить список целых чисел от N до M. `from_to(1, 4, L)` => `[1, 2, 3, 4]`

**Как работает:**
1. Если `N > M` — список пуст, `!` запрещает пробовать второй клоз (cut)
2. Иначе — голова результата это `N`, хвост `T` строится рекурсивно с `N+1`
3. Рекурсия раскручивается обратно и Prolog собирает список

```
from_to(1, 4, L)
  → [1 | T], from_to(2, 4, T)
  → [1, 2 | T], from_to(3, 4, T)
  → [1, 2, 3 | T], from_to(4, 4, T)
  → [1, 2, 3, 4 | T], from_to(5, 4, T)
  → N > M, T = []
  → L = [1, 2, 3, 4]
```

**Описание:** Два клоза — базовый случай (пустой список) и рекурсивный шаг. Паттерн `[N|T]` строит список: `N` — голова, `T` — хвост, который заполнится на следующих шагах рекурсии.

---

## Задание 3. `delta(List, DeltaList)`

**Условие:** заменить каждый элемент кроме первого на разность с предыдущим. `delta([1,2,4,3], D)` => `[1, 1, 2, -1]`

**Как работает:**
1. Первый элемент списка идёт в результат без изменений
2. Вспомогательный предикат `delta_aux` обходит остаток, запоминая предыдущий элемент
3. На каждом шаге считает `Diff is H - Prev` и передаёт текущий элемент как новый `Prev`

```
delta([1, 2, 4, 3], D)
  H=1, результат начинается с 1
  delta_aux(1, [2,4,3], D)
    Prev=1, H=2,  Diff = 2-1 = 1
    delta_aux(2, [4,3], Rest)
      Prev=2, H=4,  Diff = 4-2 = 2
      delta_aux(4, [3], Rest)
        Prev=4, H=3,  Diff = 3-4 = -1
        delta_aux(3, [], [])
      Rest = [-1]
    Rest = [2, -1]
  D = [1, 2, -1]
результат = [1, 1, 2, -1]
```

**Описание:** Вспомогательный предикат `delta_aux` нужен, чтобы передавать предыдущий элемент через рекурсию. Без него нет способа помнить предыдущий элемент между шагами.

---

## Задание 4. `int_to_binary(N, S)`

**Условие:** вернуть двоичную запись числа N в виде строки. `int_to_binary(8, S)` => `"1000"`, `int_to_binary(-2, S)` => `"-10"`

**Как работает:**
1. Три клоза: ноль → `"0"`, положительное → рекурсивный сбор битов, отрицательное → конвертируем абсолютное значение и дописываем `"-"`
2. `collect_bits` делит N на 2, остаток — очередной бит, кладёт в аккумулятор. Аккумулятор собирает биты от старшего к младшему (MSB first) благодаря тому что мы передаём `[Bit|Acc]` и рекурсируем до нуля
3. `bits_to_string` превращает список цифр в строку: `0'0` это ASCII-код символа `'0'` (48), `Bit + 0'0` даёт ASCII-код `'0'` или `'1'`
4. `string_codes` собирает список кодов в строку

```
collect_bits(8, [], Bits)
  Bit = 8 mod 2 = 0, N1 = 8 // 2 = 4
  collect_bits(4, [0], Bits)
    Bit = 0, N1 = 2
    collect_bits(2, [0,0], Bits)
      Bit = 0, N1 = 1
      collect_bits(1, [0,0,0], Bits)
        Bit = 1, N1 = 0
        collect_bits(0, [1,0,0,0], Bits)
          Bits = [1,0,0,0]
bits_to_string([1,0,0,0], S) → S = "1000"
```

**Описание:** Ручная рекурсия через деление на 2. Аккумулятор `Acc` собирает биты в правильном порядке: новый бит становится головой, поэтому когда рекурсия доходит до 0, аккумулятор уже содержит биты от старшего к младшему.

---

## Задание 5. `rle_encode(List, Encoded)`

**Условие:** закодировать список методом RLE — серии одинаковых элементов заменить на `{Элемент, Количество}`. `rle_encode([a,a,a,b,c,c,a,a], E)` => `[{a,3}, b, {c,2}, {a,2}]`

**Как работает:**
1. `rle_encode` берёт голову списка `H` и вызывает `rle_run` чтобы посчитать длину серии
2. `rle_run` идёт по списку пока элементы совпадают с `H`, считает через аккумулятор
3. Когда серия кончается, возвращает `Count` и `Rest` (остаток после серии)
4. `if-then-else` (`->` `;`): если `Count = 1` — элемент одиночный, иначе — оборачиваем в `{H, Count}`
5. Рекурсия по `Rest`

```
rle_encode([a,a,a,b,c,c,a,a], E)
  H=a, rle_run(a, [a,a,b,...], 1, Count, Rest)
    a==a → Acc=2, rle_run(a, [a,b,...], 2, ...)
    a==a → Acc=3, rle_run(a, [b,...], 3, ...)
    a\=b → Count=3, Rest=[b,c,c,a,a]
  Count=3 ≠ 1 → Encoded = [{a,3} | RestEncoded]
  rle_encode([b,c,c,a,a], RestEncoded)
    H=b, rle_run(b, [c,...], 1, Count, Rest)
      b\=c → Count=1, Rest=[c,c,a,a]
    Count=1 → Encoded = [b | RestEncoded]
    ...
```

**Описание:** Два предиката — `rle_encode` управляет обходом, `rle_run` считает длину одной серии. `==` — строгое структурное равенство, работает для атомов и любых термов. `{a, 3}` в Prolog это синтаксический сахар для терма `'{}'(a, 3)`.

---

## Задание 6. `intersect(List1, List2, Result)`

**Условие:** найти общие элементы двух списков. `intersect([1,3,2,5], [2,3,4], R)` => `[3, 2]`

**Как работает:**
1. Базовый случай: пустой список — результат пуст
2. Если голова `H` есть в `L2` (проверяем через `member`) — включаем в результат, `!` убирает лишний бэктрекинг
3. Если `H` нет в `L2` — пропускаем, рекурсия по хвосту

```
intersect([1,3,2,5], [2,3,4], R)
  H=1, member(1, [2,3,4])? Нет → пропускаем
  H=3, member(3, [2,3,4])? Да → R = [3 | Rest]
    intersect([2,5], [2,3,4], Rest)
      H=2, member(2, [2,3,4])? Да → Rest = [2 | Rest2]
        intersect([5], [2,3,4], Rest2)
          H=5, нет → пропускаем
          intersect([], ...) → []
        Rest2 = []
      Rest = [2]
  R = [3, 2]
```

**Описание:** `member(X, List)` — встроенный предикат Prolog, истинен если `X` есть в `List`. Порядок элементов в результате соответствует порядку в `List1`.

---

## Задание 7. `is_date(D, M, Y, DayOfWeek)`

**Условие:** определить номер дня недели (Пн=1 ... Вс=7) по дате. Точка отсчёта: 1 января 2000 = суббота = 6. Только рекурсия, без формул.

**Как работает:**
1. `is_leap` — определяет високосный ли год по правилам: делится на 400, или делится на 4 но не на 100
2. `days_since_2000(Y, Days)` — рекурсивно суммирует дни всех лет от 2000 до Y. Базовый случай: `Y=2000` → 0 дней
3. `days_in_months(Y, M, Days)` — рекурсивно суммирует дни всех месяцев от января до M
4. Итого дней от 1 янв 2000: `DY + DM + D - 1` (D-1 потому что первый день — ноль смещений)
5. День недели: `(Total + 5) mod 7 + 1`. Почему +5: 1 янв 2000 = суббота = 6, а 0 дней смещения даёт 6, значит `(0 + 5) mod 7 + 1 = 6` ✓

```
is_date(1, 2, 2013, DW)
  days_since_2000(2013, DY)
    суммируем годы 2000..2012
    2000,2004,2008,2012 — високосные (4 × 366)
    остальные 9 × 365
    DY = 4749
  days_in_months(2013, 2, DM)
    январь = 31 день
    DM = 31
  Total = 4749 + 31 + 1 - 1 = 4780
  DW = (4780 + 5) mod 7 + 1 = 4785 mod 7 + 1 = 4 + 1 = 5 (пятница) ✓
```

**Описание:** Вся логика сводится к подсчёту дней от точки отсчёта через рекурсию по годам и месяцам. `is_leap` используется при подсчёте дней февраля и дней в году. `mod 7` замыкает счётчик в цикл недели.
